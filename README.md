# DNS Sim CS352
 DNS Simulator w/ Root server, Client and TLS

 # Internet Technology - Project 1: Recursive DNS client and DNS servers
 ## By Abdulrahman Abdulrahman (aa1684) and Manav Patel (mjp430)

 ### Briefly discuss how you implemented your recursive client functionality.
 The client function runs by first reading through HNS file and splitting the file by line to get the domain names. At the same time, we also delete any previous files named "RESOLVED.txt" in order to prepare for writing a new one. Our implementation loops through the found domains and attempts to connect to the root DNS server to request the DNS lookup. The root server will return a response and if the flag returned is "A", we simply write the output to the "RESOLVED.txt" file and continue looping through the domains. If the returned flag is "NS", this indicates that the root server did not have an answer to our query and we must now make a connection to the top-level DNS server for our query. Similarly to the root DNS server, we send the same request to the top-level DNS server and receive a response. We can simply write the response the server provided to our "RESOLVED.txt" file. If the response received was "NS" (which in our implementation indicates a failure), the top-level DNS server did not have an answer to our query either. In this scenario, we output as instructed, printing the hostname as well as an error message to the file.

 Both the root DNS server and top-level DNS servers function similarly. The root server receives a port on startup and reads the DNSRS file. The root server reads through the DNSRS file adds all the entries to a dictionary. It separates parameters by spaces as well as sets the domain names to lowercase in order to add case-insensitivity to the function. Once this is done, we start the server and begin listening for a connection. At this point, the server simply hangs until a client connects to the server. Once a connection is made, the server attempts to receive a message from he client and once this message is received, it should have received a query request. With this, we simply check to see if the entry is in the dictionary we created earlier. If it is, great! We can send back the answer to the query. If not, the root DNS server will respond with the "NS" flag which will tell the client to connect to the top-level DNS server for the request instead. As stated previously, the top-level DNS server functions very similarly to the root DNS server. It received an input which acts as the port number and then reads through the DNSTS file to get a dictionary of domain names and addresses. The difference here between the root server and top-level server is that we do not need to account for the "NS" flag as all entries here are the only remaining entries our servers would know. Once this dictionary is compiled, the server is started on the specified port and listens for a connection. Once a client has connected to the server with a request for an address, the top-level server searches through the dictionary to see if it finds a match. If it does, it returns a response with the proper entry and a flag of "A" and if it doesn't, it returns a response "NS", which will indicate to the client that the hostname was not found.

 ### Are there known issues or functions that aren't working currently in your attached code? If so, explain.
 Currently, assuming all inputs and input files are formatted properly, there does not appear to be any issues with the program. The only functionality that isn't implemented is regarding the servers. The servers currently need to be manually shut down through the terminal. Since every domain lookup requires a connection the server and we wouldn't have any way for the server to know how many requests it would receive, the server is constantly running to ensure it can always return a response. Besides this, we haven't run into any major issues or causes for concern.

 ### What problems did you face developing code for this project?
 The biggest issue we faced during this project was ensuring that the client-socket connections worked from multiple hosts. Since both partners were primarily knowledgeable on socket programming in Python 3+, learning to make everything work in Python 2.7 took some time. However, we managed to get it working and tested the program running both servers and the client programs on different machines. Other than this, both partners managed to finish the project without much issue.

 ### Reflect on what you learned by working on this project.
 This project demonstrated the functionality of a DNS system on a smaller scale. We learned how DNS lookups function by sending requests from servers and parsing through that information on the server side. We also learned how multiple servers can aid in this functionality if the lookup was done on a much larger scale. Furthermore, we learned more about how client-socket connections work as well as learned how to set up servers in python which can be connected to from any host.
